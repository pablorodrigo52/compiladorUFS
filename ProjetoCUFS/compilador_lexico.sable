/* compilador_lexico.sable:
      Contem toda a descrição lexica da linguagem  
*/ 
Package compilador ;
     
Helpers 
    /* Our helpers */ 
    
    
    tudo = [0 .. 0xFFFF];
    
    // Definição de letras e numeros
    letra = ['a' .. 'z'] | ['A' .. 'Z'];  /* abcdefghijklmnopqrstuvwxyz */
    num = ['0' .. '9'] ; /* 0123456789 */
     
     
    // Definição de caracteres especiais 
 	spc = ' ' ; //Espaço em branco 
    under = '_' ; 
    virgula = ',' ;
    aspasimples = '''; 
    aspasduplas = '"'; 
    
    
    // caractere de nova linha e tabulacao, \n e \t
    cr = 13 ;
    nl = 10 ;
    tb = 9;

	// vazio representa simbolos em branco que devo ignorar
	vazio = (spc)+ ;
	// Caractere de tabulação
	tab = tb;
	// Caractere que representa \r ou \r\n (para quebra de linha) 
	rn = (cr | cr nl);

	nao = 'nao' ;
    e = 'e' ;
    ou = 'ou' ;
    xor = 'xor';

	maior = '>' ;
	menor = '<' ;
	igual = '=' ;
	verdadeiro = 'verdadeiro' ;
    falso = 'falso';

States
	normal, comentario_bloco;

Tokens 
    /* Abaixo está definido algumas palavras que são reservadas na linguagem.
    Baseado totalmente no PDF que foi passado pelo professor da turma e também
    na linguagem de programação C */
   
   inicio = 'inicio' nl? ;
   fim = 'fim.' nl? ;
   se = 'se' ;
   fimse = 'fim se' ;
   entao = 'entao' ;
   senao = 'senao' ;
   enquanto = 'enquanto' ;
   fimenquanto = 'fim enquanto';
   para = 'para' ;
   de = 'de';
   passo = 'passo'; 
   fimpara = 'fim para';
   avalie = 'avalie' ;
   fimavalie = 'fim avalie'; 
   caso = 'caso' ;
   pare = 'pare'; //break
   repita = 'repita'; 
   ate = 'ate'; 
   programa = 'programa' nl? ;
   leia = 'leia' ;
   escreva = 'escreva' ;
   constante = 'const' ;
   nulo = 'nulo'; //null 
   retorne = 'retorne'; //return
   faca = 'faca'; //do {...} while();
   verdadeiro = verdadeiro;
   falso = falso;
   
        //OPERADORES LÓGICOS
   diferente = menor maior;
   maioreq = maior igual ;
   menorq = menor igual ;
   maior =  maior ;
   menor = menor ;
   igual = igual ;
   
    //OPERADORES ARITMÉTICOS
   mult = '*' ;
   div = '/' ;
   sum = '+' ;
   sub = '-' ;
   mod = '%' ;
   
	//OPERADORES BOOLEANOS
   nao = nao ;
   e = e ;
   ou = ou ;
   xor = xor; 
   
     //TIPOS
   tipointeiro = 'inteiro' ;
   tiporeal = 'real' ;
   tipocaractere = 'caractere' ;
   tipobooleano = 'booleano' ; 
   
     //SIMBOLOS ESPECIAIS
   virgula 	= virgula ;
   ponto = '.' ; 
   pontoevirgula = ';' ;
   fechablococomentario = '*/' nl? ;
   abreblococomentario = '/*' nl? ;
   doispontos = ':' ;
   comentariosimples = '//' ; 
   aparentese = '(' ;
   fparentese = ')' ;
   acolchete = '[' ;
   fcolchete = ']' ;
   atrib = ':=' ;
   aspasimples = aspasimples;
   aspasduplas = aspasduplas;  
   
   novalinha = nl;
   vazio = vazio ;
   tab = tab;
   rn = rn;
   
     //IDENTIFICADORES, INTEIRO, REAL, caractere, string, booleano
   id = (under|letra) (letra*|under*|num*)+ ;
   inteiro = num+ ;
   real = num+ virgula num+ ;
   caractere = aspasimples letra aspasimples;
   string = aspasimples (letra|num|vazio)+ aspasimples;
   booleano = verdadeiro | falso ;
   
Ignored Tokens
	vazio, novalinha, tab, rn ;
	
Productions
	
	prog = {inicio} programa id inicio declaracao*  comando* fim ; //falta a parte de comando ainda, pra rodar, tem que tirar comando daqui..
	//_______________________________________________________ DECLARAÇÕES:
	declaracao = {variaveis} tipo doispontos var pontoevirgula 
			   | {constante} constante id valor pontoevirgula ;   
	var = {varias_variaveis} var_ou_vetor virgula var
		| {uma_variavel} var_ou_vetor;
	var_ou_vetor = {variavel} id
			 	 | {vetor} id acolchete posicao fcolchete ;
	posicao = {um_identificador} id |{um_inteiro} inteiro; 
	
	//________________________________________________ COMANDOS:
	comandos = {comando_condicional} cond_comando? ;
	cond_comando = {varios_comandos} comando+ ;
	comando = {atribuicao_variavel} var atrib exp pontoevirgula |
			  {comando_leia} leia aparentese var fparentese pontoevirgula |
			  {comando_escreva} escreva aparentese exp_escreva fparentese pontoevirgula |
			  {comando_se} se condicao_se entao causa_se fimse pontoevirgula |
			  {comando_avalie} avalie condicao_avalie casos_avalie fimavalie pontoevirgula |
			  {comando_enquanto} enquanto condicao_se faca comandos comando fimenquanto pontoevirgula |
			  {comando_repita} repita comandos ate condicao_se pontoevirgula |
			  {comando_para1} para var de [frist]:inteiro ate [second]:inteiro faca comandos comando fimpara [four]:pontoevirgula |
			  {comando_para2} para var de [fifth]:inteiro passo [sixth]:inteiro faca comandos comando fimpara pontoevirgula ;
	exp_escreva = {varias_expressoes} exp_ou_explogica virgula exp_escreva |
				  {uma_expressao} exp_ou_explogica; 
	exp_ou_explogica = exp;
	condicao_se = {condicao_se} aparentese exp_logica fparentese ;
	causa_se = {causa_se} comandos comando comando_senao? ;
	comando_senao = {comando_senao_se} senao comandos comando |
				    {comando_senao_avalie} senao doispontos comandos comando ;
	condicao_avalie = aparentese exp fparentese; 
	casos_avalie = cond_comando_casos? comando_senao? ;
	cond_comando_casos = {varios_cases} comando_caso+ ;
	comando_caso = {comando_case} caso valor doispontos comandos comando;
	cond_comando_para = {varios_comandos_para} comando_para+;
	comando_para = {comando_para} comando ;
	
	// EXPRESSAO (PODE SER ARITMETICA OU LÓGICA
	exp = {expressao} expressao | {exp_logica} exp_logica ;
	expressao = {soma} expressao sum termo |
				{sub} expressao sub termo |
				{mult} expressao mult termo |
				{div} expressao div termo |
				{termo} termo ;	
	termo = {final} expressao_final ;
	expressao_final = {valor_aninahdo} aparentese expressao fparentese |
					  {uma_variavel} var_ou_vetor |
					  {variavel_negativa} sub expressao_final |
					  {valor_final} valor ;
					   		  
	//______________________________________ LOGICA:
	exp_logica = {e} exp_logica e termo_logico |
				 {ou} exp_logica ou termo_logico |
				 {xor} exp_logica xor termo_logico |
				 {nao} nao termo_logico |
				 {exp_aninhada} aparentese exp_logica fparentese |
				 {termo_logico} termo_logico ; 
	termo_logico = {fator_logico} fator_logico; 
	fator_logico = {igual} expressao igual termo |
				   {maior} expressao maior termo |
				   {menor} expressao menor termo |
				   {maiorq} expressao maioreq termo |
				   {menorq} expressao menorq termo |
				   {diferente} expressao diferente termo ;	
	tipo = {tint} tipointeiro | {tfloat} tiporeal | {tstr} tipocaractere | {tbool} tipobooleano ;
	valor = {int} inteiro | {float} real | {str} string | {bool} booleano | {char} caractere;